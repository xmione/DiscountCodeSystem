# .NET Principles and Design Patterns in Discount Code System

This document outlines the .NET principles and design patterns implemented in the Discount Code System application.

## .NET Principles

### 1. **Async/Await Pattern**
- **Usage**: Throughout the application for non-blocking I/O operations
- **Examples**:
  ```csharp
  public async Task<GenerateResponse> GenerateCodesAsync(ushort count, byte length)
  public async Task HandleClientAsync(TcpClient client)
  await _repository.CodeExistsAsync(code)
  ```
- **Benefits**: Efficient thread usage, scalability, responsive UI

### 2. **Dependency Injection (DI) Principle**
- **Usage**: Manual dependency injection without a container
- **Examples**:
  ```csharp
  var repository = new DatabaseRepository(dbPath);
  var discountService = new DiscountService(repository);
  var server = new TcpServer("127.0.0.1", 8888, discountService);
  ```
- **Benefits**: Loose coupling, testability, maintainability

### 3. **Separation of Concerns (SoC)**
- **Usage**: Each component has a single responsibility
- **Examples**:
  - \`TcpServer\`: Network communication
  - \`DiscountService\`: Business logic
  - \`DatabaseRepository\`: Data persistence
- **Benefits**: Modular design, easier maintenance, focused testing

### 4. **SOLID Principles**
- **Single Responsibility Principle (SRP)**:
  - Each class has one reason to change
  - \`DatabaseRepository\` only handles database operations
  - \`DiscountService\` only handles business rules

- **Open/Closed Principle (OCP)**:
  - Open for extension (new message types)
  - Closed for modification (core TCP handling)

- **Liskov Substitution Principle (LSP)**:
  - Not heavily used (minimal inheritance)

- **Interface Segregation Principle (ISP)**:
  - Could be improved by adding interfaces for repository and service

- **Dependency Inversion Principle (DIP)**:
  - High-level modules don't depend on low-level modules
  - Both depend on abstractions (could be improved with interfaces)

### 5. **Resource Management**
- **Usage**: Proper disposal of resources
- **Examples**:
  ```csharp
  using var connection = new SqliteConnection(_connectionString);
  using var stream = client.GetStream();
  ```
- **Benefits**: Prevents resource leaks, automatic cleanup

### 6. **Exception Handling**
- **Usage**: Structured error handling
- **Examples**:
  ```csharp
  try
  {
      // Processing logic
  }
  catch (Exception ex)
  {
      Console.WriteLine(\$"Error: {ex.Message}");
  }
  ```
- **Benefits**: Graceful error recovery, application stability

## Design Patterns

### 1. **Repository Pattern**
- **Purpose**: Abstracts data access logic
- **Implementation**:
  ```csharp
  public class DatabaseRepository
  {
      public async Task<bool> CodeExistsAsync(string code)
      public async Task<bool> InsertCodeAsync(string code)
      public async Task<byte> UseCodeAsync(string code)
  }
  ```
- **Benefits**: Decouples business logic from data access, testability

### 2. **Service Layer Pattern**
- **Purpose**: Encapsulates business logic
- **Implementation**:
  ```csharp
  public class DiscountService
  {
      public async Task<GenerateResponse> GenerateCodesAsync(ushort count, byte length)
      public async Task<UseCodeResponse> UseCodeAsync(string code)
  }
  ```
- **Benefits**: Centralized business rules, separation from presentation

### 3. **Active Object Pattern**
- **Purpose**: Concurrent request processing
- **Implementation**:
  ```csharp
  var client = await _listener.AcceptTcpClientAsync();
  _ = HandleClientAsync(client); // Fire and forget
  ```
- **Benefits**: Efficient concurrency, non-blocking operations

### 4. **Command Pattern**
- **Purpose**: Encapsulates requests as objects
- **Implementation**:
  ```csharp
  // Message type determines command
  var messageType = reader.ReadByte();
  if (messageType == 1) // Generate codes command
  if (messageType == 2) // Use code command
  ```
- **Benefits**: Decouples sender from receiver, supports undo/redo

### 5. **Strategy Pattern (Implicit)**
- **Purpose**: Encapsulates algorithm family
- **Implementation**:
  ```csharp
  // Code generation strategy
  var code = new string(Enumerable.Repeat(AllowedChars, length)
      .Select(s => s[_random.Next(s.Length)]).ToArray());
  ```
- **Benefits**: Algorithm flexibility, runtime selection

### 6. **Factory Pattern (Implicit)**
- **Purpose**: Object creation without specifying exact class
- **Implementation**:
  ```csharp
  // Response object creation
  return new GenerateResponse { Result = true, Codes = codes };
  return new UseCodeResponse { Result = 0 };
  ```
- **Benefits**: Decouples client from concrete classes

### 7. **Object Pool Pattern (ThreadPool)**
- **Purpose**: Reuse objects to avoid allocation overhead
- **Implementation**:
  ```csharp
  // .NET ThreadPool manages thread reuse
  _ = HandleClientAsync(client); // Uses ThreadPool
  ```
- **Benefits**: Reduced resource allocation, improved performance

### 8. **Retry Pattern (Tests)**
- **Purpose**: Handle transient failures
- **Implementation**:
  ```csharp
  for (int i = 0; i < 5; i++)
  {
      try
      {
          Directory.Delete(_tempDir, true);
          break;
      }
      catch (IOException)
      {
          Thread.Sleep(100 * (i + 1));
      }
  }
  ```
- **Benefits**: Improved reliability, handles temporary issues

### 9. **Monitor Object Pattern**
- **Purpose**: Synchronized access to shared resources
- **Implementation**:
  ```csharp
  // SQLite handles concurrent access automatically
  await using var connection = new SqliteConnection(_connectionString);
  ```
- **Benefits**: Thread safety, prevents race conditions

### 10. **Null Object Pattern (Potential)**
- **Purpose**: Provide default behavior for null references
- **Implementation**:
  ```csharp
  // Could be used for default responses
  return new GenerateResponse { Result = false };
  ```
- **Benefits**: Eliminates null checks, simplifies code

## Architecture Patterns

### 1. **Layered Architecture**
- **Layers**:
  - Presentation Layer: TCP Server
  - Business Layer: Discount Service
  - Data Access Layer: Database Repository
- **Benefits**: Separation of concerns, maintainability

### 2. **Client-Server Architecture**
- **Implementation**:
  - Server: Discount code processing
  - Client: Test application
- **Benefits**: Distributed processing, scalability

### 3. **Event-Driven Architecture**
- **Implementation**:
  ```csharp
  // Event-driven by client connections
  var client = await _listener.AcceptTcpClientAsync();
  ```
- **Benefits**: Responsive, efficient resource usage

## Additional Patterns

### 1. **Template Method Pattern**
- **Implementation**:
  ```csharp
  // Base processing flow in HandleClientAsync
  while (client.Connected)
  {
      var messageType = reader.ReadByte();
      // Process based on message type
  }
  ```
- **Benefits**: Algorithm skeleton, consistent processing

### 2. **State Pattern (Potential)**
- **Implementation**:
  ```csharp
  // Code states: unused, used
  public byte UseCodeAsync(string code)
  ```
- **Benefits**: State-specific behavior, clean state transitions

### 3. **Decorator Pattern (Potential Extension)**
- **Usage**: Could add logging, caching, or validation decorators
- **Benefits**: Flexible functionality addition, open/closed principle

## Summary

The application demonstrates strong adherence to modern .NET principles and effectively implements several design patterns:

- **Core Strengths**: Async/await usage, separation of concerns, repository pattern, service layer
- **Scalability**: Task-based concurrency, efficient resource management
- **Maintainability**: SOLID principles, layered architecture
- **Testability**: Dependency injection, repository abstraction
- **Robustness**: Exception handling, resource management

The design follows .NET best practices and provides a solid foundation that could be extended with additional patterns like Dependency Injection containers, CQRS, or Event Sourcing if needed for more complex scenarios.